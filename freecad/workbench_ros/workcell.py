"""Proxy for a RosWorkcell, i.e. a combination of RosXacroObject and RosJoint

A RosWorkcell allows to combine existing URDF and xacro file to generate a
single robot description (or more generally a workcell description).
Joints must be defined between the included RosXacroObject.

"""

from __future__ import annotations

from pathlib import Path
from typing import Iterable, Optional
import xml.etree.ElementTree as et

import FreeCAD as fc

from .freecad_utils import add_property
from .freecad_utils import warn
from .ros_utils import split_package_path
from .urdf_utils import urdf_origin_from_placement
from .utils import get_valid_filename
from .utils import get_valid_urdf_name
from .utils import get_xacro_objects
from .utils import save_xml
from .wb_utils import export_templates
from .wb_utils import ros_name

# Typing hints.
DO = fc.DocumentObject
VPDO = 'FreeCADGui.ViewProviderDocumentObject'
DOList = Iterable[DO]
RosJoint = DO  # A Ros::Joint, i.e. a DocumentObject with Proxy "Joint".
RosWorkcell = DO  # A Ros::Workcell, i.e. a DocumentObject with Proxy "Workcell".
RosXacroObject = DO  # A Ros::XacroObject, i.e. a DocumentObject with Proxy "XacroObject".


class Workcell:
    """Proxy for ROS workcells."""

    # The member is often used in workbenches, particularly in the Draft
    # workbench, to identify the object type.
    Type = 'Ros::Workcell'

    def __init__(self, obj: RosWorkcell):
        obj.Proxy = self
        self.workcell = obj
        self.init_properties(obj)

    def init_properties(self, obj: RosWorkcell) -> None:
        add_property(obj, 'App::PropertyString', '_Type', 'Internal',
                     'The type')
        obj.setPropertyStatus('_Type', ['Hidden', 'ReadOnly'])
        obj._Type = self.Type

        add_property(obj, 'App::PropertyPath', 'OutputPath', 'Export',
                     'The path to the ROS package to export files to')

    def execute(self, obj: RosWorkcell) -> None:
        pass

    def onBeforeChange(self, obj: RosWorkcell, prop: str) -> None:
        # TODO: save the old ros_name and update all joints that used it.
        pass

    def onChanged(self, obj: RosWorkcell, prop: str) -> None:
        pass

    def onDocumentRestored(self, obj: RosWorkcell) -> None:
        self.__init__(obj)

    def __getstate__(self):
        return self.Type,

    def __setstate__(self, state):
        if state:
            self.Type, = state

    def get_xacro_objects(self) -> list[RosXacroObject]:
        if ((not hasattr(self, 'workcell'))
                or (not hasattr(self.workcell, 'Group'))):
            return []
        return get_xacro_objects(self.workcell.Group)

    def export_urdf(self) -> Optional[et.Element]:
        if ((not hasattr(self, 'workcell'))
                or (not hasattr(self.workcell, 'OutputPath'))):
            return
        obj: RosWorkcell = self.workcell
        if not obj.OutputPath:
            warn('Property `OutputPath` cannot be empty', True)
            return

        robot_et = et.fromstring('<robot/>')
        robot_et.attrib['name'] = get_valid_urdf_name(self.workcell.Label)
        robot_et.append(et.Comment('Generated by the ROS Workbench for'
                                   ' FreeCAD (https://github.com/galou/'
                                   'freecad.workbench_ros)'))

        # Add the link "world".
        world_link_et = et.fromstring('<link/>')
        world_link_et.attrib['name'] = 'world'
        robot_et.append(world_link_et)

        root_links: list[str] = []
        includes: list[et.Element] = []
        for xacro_object in self.get_xacro_objects():
            root_link = xacro_object.Proxy.root_link
            root_links.append(root_link)

            # Add the xacro's children.
            xacro_et = xacro_object.Proxy.export_urdf()
            for child_et in xacro_et:
                if child_et.tag == 'xmlns:include':
                    includes.append(child_et)
                robot_et.append(child_et)

            # Add the link "world" and a transform from it to the root link.
            joint_et = et.fromstring('<joint/>')
            joint_et.attrib['name'] = f'world_to_{root_link}'
            joint_et.attrib['type'] = 'fixed'
            parent_et = et.fromstring('<parent/>')
            parent_et.attrib['link'] = world_link_et.attrib['name']
            joint_et.append(parent_et)
            child_et = et.fromstring('<child/>')
            child_et.attrib['link'] = root_link
            joint_et.append(child_et)
            # TODO: solve global placement.
            origin_et = urdf_origin_from_placement(xacro_object.Placement)
            joint_et.append(origin_et)
            robot_et.append(joint_et)

        # Write out files.
        output_path = Path(obj.OutputPath).expanduser()
        package_parent, package_name = split_package_path(output_path)
        output_path.mkdir(parents=True, exist_ok=True)
        robot_name = ros_name(self.workcell)
        file_base = get_valid_filename(robot_name)
        urdf_file = f'{file_base}.urdf.xacro'
        urdf_path = output_path / f'urdf/{urdf_file}'
        save_xml(robot_et, urdf_path)
        template_files = [
            'package.xml',
            'CMakeLists.txt',
            'launch/display.launch.py',
            'rviz/robot_description.rviz',
            ]
        export_templates(template_files,
                         package_parent,
                         package_name=package_name,
                         urdf_file=urdf_file)


class _ViewProviderWorkcell:
    """A view provider for the Link container object """

    def __init__(self, vobj: VPDO):
        vobj.Proxy = self

    def getIcon(self):
        return 'workcell.svg'

    def attach(self, vobj: VPDO):
        self.ViewObject = vobj

    def updateData(self, obj: VPDO, prop):
        return

    def onChanged(self, vobj: VPDO, prop: str):
        return

    def __getstate__(self):
        return None

    def __setstate__(self, state):
        return None


def make_workcell(name, doc: Optional[fc.Document] = None) -> RosWorkcell:
    """Add a Ros::Workcell to the current document."""
    if doc is None:
        doc = fc.activeDocument()
    if doc is None:
        warn('No active document, doing nothing', False)
        return
    obj = doc.addObject('App::DocumentObjectGroupPython', name)
    Workcell(obj)

    if hasattr(fc, 'GuiUp') and fc.GuiUp:
        _ViewProviderWorkcell(obj.ViewObject)

    return obj
