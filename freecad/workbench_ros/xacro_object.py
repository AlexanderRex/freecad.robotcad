from __future__ import annotations

from typing import Optional

import FreeCAD as fc

from .freecad_utils import add_property
from .freecad_utils import warn
from .utils import hasallattr
from .utils import is_robot
from .xacro_loader import Xacro
from .xacro_loader import XacroLoader

# Typing hints.
DO = fc.DocumentObject
VPDO = 'FreeCADGui.ViewProviderDocumentObject'
RosXacroObject = DO  # A Ros::XacroObject, i.e. a DocumentObject with Proxy "Xacro".


class XacroObject:
    """The XacroObject proxy."""

    # The member is often used in workbenches, particularly in the Draft
    # workbench, to identify the object type.
    Type = 'Ros::XacroObject'

    def __init__(self, obj: RosXacroObject):
        obj.Proxy = self
        self.xacro_object = obj

        # List of macro parameters.
        self.param_properties: list[str] = []

        # xacro_loader.Xacro instance, generated by XacroLoader.
        self.xacro: Optional[Xacro] = None

        self.init_properties(obj)
        self.init_extensions(obj)

    def init_properties(self, obj: RosXacroObject):
        add_property(obj, 'App::PropertyString', '_Type', 'Internal',
                     'The type')
        obj.setPropertyStatus('_Type', ['Hidden', 'ReadOnly'])
        obj._Type = self.Type

        add_property(obj, 'App::PropertyFile', 'InputFile', 'Input',
                     'The source xacro or URDF file')
        add_property(obj, 'App::PropertyEnumeration', 'MainMacro', 'Input',
                     'The macro to use')
        # Hide until an input file is given.
        obj.setPropertyStatus('MainMacro', ['Hidden'])

    def init_extensions(self, obj: RosXacroObject):
        # Needed to make this object able to attach parameterically to other objects.
        obj.addExtension('Part::AttachExtensionPython')
        # Need a group to put the generated robot in.
        obj.addExtension('App::GroupExtensionPython')

        # Managed in self.reset_group().
        obj.setPropertyStatus('Group', ['ReadOnly', 'Hidden'])

    def execute(self, obj: RosXacroObject) -> None:
        print('execute()')
        obj.positionBySupport()
        if (not hasallattr(obj, ['InputFile', 'MainMacro'])):
            return
        if not obj.InputFile:
            return
        self.xacro = XacroLoader.load_from_file(self.xacro_object.InputFile)
        macro_names = self.xacro.get_macro_names()
        if self.xacro_object.getEnumerationsOfProperty('MainMacro') != macro_names:
            self.xacro_object.MainMacro = macro_names
        if macro_names:
            obj.setEditorMode('MainMacro', [])
        else:
            obj.setPropertyStatus('MainMacro', ['Hidden'])
        self.set_param_properties(obj)
        # self.reset_group()
        pass

    def onChanged(self, obj: RosXacroObject, prop: str) -> None:
        if prop in ['InputFile']:
            self.execute(obj)

    def onDocumentRestored(self, obj):
        """Restore attributes because __init__ is not called on restore."""
        self.__init__(obj)

    def __getstate__(self):
        return self.Type,

    def __setstate__(self, state):
        if state:
            self.Type, = state

    def set_param_properties(self, obj: RosXacroObject) -> None:
        # Clear old parameters.
        for name in self.param_properties:
            obj.removeProperty(name)
        if (not hasallattr(obj, ['InputFile', 'MainMacro'])):
            return
        if self.xacro:
            macro = self.xacro.macros[obj.MainMacro]
            for name in macro.params:
                add_property(obj, 'App::PropertyString', name, 'Input',
                             f'Macro parameter "{name}"')
                if name in macro.defaultmap:
                    # Implementation note: cannot set the property value
                    # knowing the property name, __setattr__ doesn't work.
                    value = (macro.defaultmap[name][1]
                             .replace('{', '')
                             .replace('}', ''))
                    obj.setExpression(name, f'<<{value}>>')
                    # It looks that it's better to keep the expression rather
                    # than clearing it may be interpreted as float.
                    # obj.clearExpression(name)

    def reset_group(self):
        if not hasattr(self, 'xacro'):
            return
        if not hasattr(self.xacro_object, 'Group'):
            return
        if not hasattr(self.xacro_object, 'InputFile'):
            return
        doc = self.xacro_object.Document
        if self.xacro_object.Group:
            old_robot = self.xacro_object.Group[0]
            if is_robot(old_robot):
                doc.removeObject(old_robot.Name)
            # Empty the group.
            self.xacro_object.Group = []


class _ViewProviderXacroObject:
    """A view provider for the Xacro container object """

    def __init__(self, vobj: VPDO):
        vobj.Proxy = self

    def getIcon(self):
        return 'xacro.svg'

    def attach(self, vobj: VPDO):
        self.ViewObject = vobj

    def updateData(self, obj: RosXacroObject, prop: str):
        return

    def onChanged(self, vobj: VPDO, prop: str):
        pass

    def doubleClicked(self, vobj: VPDO):
        return True

    def setEdit(self, vobj: VPDO, mode):
        return False

    def unsetEdit(self, vobj: VPDO, mode):
        return

    def __getstate__(self):
        return None

    def __setstate__(self, state):
        return None


def make_xacro_object(name, doc: Optional[fc.Document] = None) -> RosXacroObject:
    """Add a Ros::XacroObject to the current document."""
    if doc is None:
        doc = fc.activeDocument()
    if doc is None:
        warn('No active document, doing nothing', False)
        return
    obj = doc.addObject('App::FeaturePython', name)
    XacroObject(obj)

    if hasattr(fc, 'GuiUp') and fc.GuiUp:
        _ViewProviderXacroObject(obj.ViewObject)

    doc.recompute()
    return obj
