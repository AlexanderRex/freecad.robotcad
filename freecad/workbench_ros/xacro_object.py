from __future__ import annotations

from typing import Optional

import FreeCAD as fc

from .freecad_utils import add_property
from .freecad_utils import warn
from .utils import get_joints
from .utils import get_links
from .wb_utils import ros_name
try:
    from .robot_from_urdf import robot_from_urdf
    from .urdf_loader import UrdfLoader
    from .utils import hasallattr
    from .utils import is_robot
    from .xacro_loader import Xacro
    from .xacro_loader import XacroLoader
except ImportError as e:
    # TODO: Warn the user more nicely.
    # TODO: provide alternates on import error
    warn(str(e))

# Typing hints.
DO = fc.DocumentObject
VPDO = 'FreeCADGui.ViewProviderDocumentObject'
RosXacroObject = DO  # A Ros::XacroObject, i.e. a DocumentObject with Proxy "Xacro".
RosRobot = DO  # A Ros::Robot, i.e. a DocumentObject with Proxy "Robot".


def _clear_robot(obj: RosRobot) -> None:
    """Delete all joints and links from a robot."""
    doc = obj.Document
    # Joints first.
    for joint in get_joints(obj.Group):
        doc.removeObject(joint.Name)
    for link in get_links(obj.Group):
        for fc_link in link.Group:
            doc.removeObject(fc_link.Name)
        doc.removeObject(link.Name)


class XacroObject:
    """The XacroObject proxy."""

    # The member is often used in workbenches, particularly in the Draft
    # workbench, to identify the object type.
    Type = 'Ros::XacroObject'

    def __init__(self, obj: RosXacroObject):
        obj.Proxy = self
        self.xacro_object = obj

        # List of macro parameters.
        self.param_properties: list[str] = []

        # xacro_loader.Xacro instance, generated by XacroLoader.
        self.xacro: Optional[Xacro] = None

        # Keep track of the old generated xacro, to avoid rebuilding the robot.
        self._old_xacro_file_content = ''
        # Name of the temporary file to save the generated xacro file.
        self._xacro_temp_file_name = ''

        self.init_properties(obj)
        self.init_extensions(obj)

    def init_properties(self, obj: RosXacroObject):
        add_property(obj, 'App::PropertyString', '_Type', 'Internal',
                     'The type')
        obj.setPropertyStatus('_Type', ['Hidden', 'ReadOnly'])
        obj._Type = self.Type

        add_property(obj, 'App::PropertyFile', 'InputFile', 'Input',
                     'The source xacro or URDF file')
        add_property(obj, 'App::PropertyEnumeration', 'MainMacro', 'Input',
                     'The macro to use')
        # Hide until an input file is given.
        obj.setPropertyStatus('MainMacro', ['Hidden'])

    def init_extensions(self, obj: RosXacroObject):
        # Needed to make this object able to attach parameterically to other objects.
        obj.addExtension('Part::AttachExtensionPython')
        # Need a group to put the generated robot in.
        obj.addExtension('App::GroupExtensionPython')

        # Managed in self.reset_group().
        obj.setPropertyStatus('Group', ['ReadOnly', 'Hidden'])

    def execute(self, obj: RosXacroObject) -> None:
        obj.positionBySupport()
        if (not hasallattr(obj, ['InputFile', 'MainMacro'])):
            return
        if not obj.InputFile:
            return
        self.xacro = XacroLoader.load_from_file(self.xacro_object.InputFile)
        macro_names = self.xacro.get_macro_names()
        if self.xacro_object.getEnumerationsOfProperty('MainMacro') != macro_names:
            self.xacro_object.MainMacro = macro_names
        if macro_names:
            obj.setEditorMode('MainMacro', [])
        else:
            obj.setPropertyStatus('MainMacro', ['Hidden'])
        self.set_param_properties(obj)
        self.reset_group(obj)

    def onChanged(self, obj: RosXacroObject, prop: str) -> None:
        if prop in ['InputFile', 'Label', 'Label2', 'MainMacro']:
            self.execute(obj)

    def onDocumentRestored(self, obj: RosXacroObject):
        """Restore attributes because __init__ is not called on restore."""
        self.__init__(obj)

    def __getstate__(self):
        return self.Type,

    def __setstate__(self, state):
        if state:
            self.Type, = state

    def set_param_properties(self, obj: RosXacroObject) -> None:
        # Clear old parameters.
        for name in self.param_properties:
            obj.removeProperty(name)
        self.param_properties.clear()
        if (not hasallattr(obj, ['InputFile', 'MainMacro'])):
            return
        if self.xacro:
            macro = self.xacro.macros[obj.MainMacro]
            for name in macro.params:
                add_property(obj, 'App::PropertyString', name, 'Input',
                             f'Macro parameter "{name}"')
                self.param_properties.append(name)
                if name in macro.defaultmap:
                    # Implementation note: cannot set the property value
                    # knowing the property name, __setattr__ doesn't work.
                    value = (macro.defaultmap[name][1]
                             .replace('{', '')
                             .replace('}', ''))
                    obj.setExpression(name, f'<<{value}>>')
                    # It looks that it's better to keep the expression rather
                    # than clearing it may be interpreted as float.
                    # obj.clearExpression(name)

    def reset_group(self, obj: RosXacroObject):
        if not hasallattr(obj, ['Group', 'InputFile', 'MainMacro']):
            return
        new_robot = self._generate_robot(obj)
        if new_robot and obj.Group:
            old_robot = obj.Group[0]
            # Empty the group.
            obj.Group = []
            if is_robot(old_robot):
                # Delete the old robot.
                _clear_robot(old_robot)
                obj.Document.removeObject(old_robot.Name)
        if new_robot:
            # Add the new robot.
            obj.addObject(new_robot)

    def _generate_robot(self, obj: RosXacroObject) -> Optional[RosRobot]:
        params = {name: obj.getPropertyByName(name) for name in self.param_properties}
        xacro_txt = self.xacro.to_string(ros_name(obj), obj.MainMacro, params)
        if xacro_txt == self._old_xacro_file_content:
            return
        self._old_xacro_file_content = xacro_txt
        urdf_txt = self.xacro.to_urdf_string(ros_name(obj), obj.MainMacro, params)
        urdf_robot = UrdfLoader.load_from_string(urdf_txt)
        robot = robot_from_urdf(obj.Document, urdf_robot)
        return robot


class _ViewProviderXacroObject:
    """A view provider for the Xacro container object """

    def __init__(self, vobj: VPDO):
        vobj.Proxy = self

    def getIcon(self):
        return 'xacro.svg'

    def attach(self, vobj: VPDO):
        self.ViewObject = vobj
        vobj.addExtension('Gui::ViewProviderGroupExtensionPython')

    def updateData(self, obj: RosXacroObject, prop: str):
        return

    def onChanged(self, vobj: VPDO, prop: str):
        pass

    def doubleClicked(self, vobj: VPDO):
        return True

    def setEdit(self, vobj: VPDO, mode):
        return False

    def unsetEdit(self, vobj: VPDO, mode):
        return

    def __getstate__(self):
        return None

    def __setstate__(self, state):
        return None


def make_xacro_object(name, doc: Optional[fc.Document] = None) -> RosXacroObject:
    """Add a Ros::XacroObject to the current document."""
    if doc is None:
        doc = fc.activeDocument()
    if doc is None:
        warn('No active document, doing nothing', False)
        return
    obj = doc.addObject('App::FeaturePython', name)
    XacroObject(obj)

    if hasattr(fc, 'GuiUp') and fc.GuiUp:
        _ViewProviderXacroObject(obj.ViewObject)

    doc.recompute()
    return obj
